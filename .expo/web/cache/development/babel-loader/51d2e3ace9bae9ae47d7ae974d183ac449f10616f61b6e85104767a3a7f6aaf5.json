{"ast":null,"code":"import AsyncStorage from \"@react-native-async-storage/async-storage\";\nimport { v4 as uuidv4 } from \"uuid\";\nconst WORKOUTS_STORAGE_KEY = \"workouts\";\nexport const getAllWorkouts = async () => {\n  try {\n    const workoutsJson = await AsyncStorage.getItem(WORKOUTS_STORAGE_KEY);\n    return workoutsJson ? JSON.parse(workoutsJson) : [];\n  } catch (error) {\n    console.error(\"Error retrieving workouts:\", error);\n    return [];\n  }\n};\nexport const getRecentWorkouts = async limit => {\n  const workouts = await getAllWorkouts();\n  return workouts.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()).slice(0, limit);\n};\nexport const getWorkoutById = async id => {\n  const workouts = await getAllWorkouts();\n  return workouts.find(workout => workout.id === id) || null;\n};\nexport const saveWorkout = async workout => {\n  try {\n    const workouts = await getAllWorkouts();\n    if (!workout.id) {\n      workout.id = uuidv4();\n    }\n    const existingIndex = workouts.findIndex(w => w.id === workout.id);\n    if (existingIndex >= 0) {\n      workouts[existingIndex] = workout;\n    } else {\n      workouts.push(workout);\n    }\n    await AsyncStorage.setItem(WORKOUTS_STORAGE_KEY, JSON.stringify(workouts));\n    return workout;\n  } catch (error) {\n    console.error(\"Error saving workout:\", error);\n    throw error;\n  }\n};\nexport const deleteWorkout = async id => {\n  try {\n    const workouts = await getAllWorkouts();\n    const filteredWorkouts = workouts.filter(workout => workout.id !== id);\n    await AsyncStorage.setItem(WORKOUTS_STORAGE_KEY, JSON.stringify(filteredWorkouts));\n    return true;\n  } catch (error) {\n    console.error(\"Error deleting workout:\", error);\n    return false;\n  }\n};\nexport const getProgressionRecommendations = async exerciseId => {\n  try {\n    const workouts = await getAllWorkouts();\n    const relevantWorkouts = workouts.filter(workout => workout.isCompleted).sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\n    const exerciseEntries = relevantWorkouts.map(workout => workout.exercises.find(entry => entry.exerciseId === exerciseId)).filter(entry => entry !== undefined);\n    if (exerciseEntries.length < 2) {\n      return null;\n    }\n    const latestEntry = exerciseEntries[0];\n    const latestSets = latestEntry.sets.filter(set => set.isCompleted);\n    const suggestedSets = latestSets.map(set => {\n      const newSet = Object.assign({}, set, {\n        id: uuidv4(),\n        isCompleted: false\n      });\n      const allRepsCompleted = latestSets.every(s => s.isCompleted);\n      const averageRPE = latestSets.reduce((sum, s) => sum + (s.rpe || 0), 0) / latestSets.length;\n      if (allRepsCompleted && averageRPE < 8) {\n        newSet.weight = Math.round(newSet.weight * 1.05 / 2.5) * 2.5;\n        return newSet;\n      }\n      if (allRepsCompleted && averageRPE >= 8) {\n        return newSet;\n      }\n      newSet.weight = Math.round(newSet.weight * 0.95 / 2.5) * 2.5;\n      return newSet;\n    });\n    return {\n      exerciseId,\n      exerciseName: latestEntry.exercise.name,\n      suggestedSets,\n      reasoning: determineProgressionReasoning(latestSets, suggestedSets),\n      difficulty: determineDifficulty(latestSets, suggestedSets)\n    };\n  } catch (error) {\n    console.error(\"Error generating progression recommendations:\", error);\n    return null;\n  }\n};\nconst determineProgressionReasoning = (latestSets, suggestedSets) => {\n  const weightDiff = suggestedSets[0].weight - latestSets[0].weight;\n  if (weightDiff > 0) {\n    return `Based on your last workout's performance, we've increased the weight by ${weightDiff}lbs.`;\n  } else if (weightDiff < 0) {\n    return `To ensure good form and progress, we've slightly reduced the weight by ${Math.abs(weightDiff)}lbs.`;\n  } else {\n    return \"Based on your last workout, we recommend maintaining the same weight to continue building strength.\";\n  }\n};\nconst determineDifficulty = (latestSets, suggestedSets) => {\n  const totalWeightDiff = suggestedSets.reduce((sum, set, index) => {\n    return sum + (set.weight - latestSets[index].weight);\n  }, 0);\n  if (totalWeightDiff > 0) return \"harder\";\n  if (totalWeightDiff < 0) return \"easier\";\n  return \"same\";\n};\nexport const getActiveWorkout = async () => {\n  const workouts = await getAllWorkouts();\n  return workouts.find(workout => workout.isActive) || null;\n};","map":{"version":3,"names":["AsyncStorage","v4","uuidv4","WORKOUTS_STORAGE_KEY","getAllWorkouts","workoutsJson","getItem","JSON","parse","error","console","getRecentWorkouts","limit","workouts","sort","a","b","Date","date","getTime","slice","getWorkoutById","id","find","workout","saveWorkout","existingIndex","findIndex","w","push","setItem","stringify","deleteWorkout","filteredWorkouts","filter","getProgressionRecommendations","exerciseId","relevantWorkouts","isCompleted","exerciseEntries","map","exercises","entry","undefined","length","latestEntry","latestSets","sets","set","suggestedSets","newSet","Object","assign","allRepsCompleted","every","s","averageRPE","reduce","sum","rpe","weight","Math","round","exerciseName","exercise","name","reasoning","determineProgressionReasoning","difficulty","determineDifficulty","weightDiff","abs","totalWeightDiff","index","getActiveWorkout","isActive"],"sources":["/Users/recep/Gym/services/workoutService.ts"],"sourcesContent":["import AsyncStorage from \"@react-native-async-storage/async-storage\"\nimport { v4 as uuidv4 } from \"uuid\"\nimport type { Workout, ProgressionRecommendation } from \"../models/Workout\"\n\n// Keys for AsyncStorage\nconst WORKOUTS_STORAGE_KEY = \"workouts\"\n\n// Get all workouts\nexport const getAllWorkouts = async (): Promise<Workout[]> => {\n  try {\n    const workoutsJson = await AsyncStorage.getItem(WORKOUTS_STORAGE_KEY)\n    return workoutsJson ? JSON.parse(workoutsJson) : []\n  } catch (error) {\n    console.error(\"Error retrieving workouts:\", error)\n    return []\n  }\n}\n\n// Get recent workouts\nexport const getRecentWorkouts = async (limit: number): Promise<Workout[]> => {\n  const workouts = await getAllWorkouts()\n  return workouts.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()).slice(0, limit)\n}\n\n// Get a workout by ID\nexport const getWorkoutById = async (id: string): Promise<Workout | null> => {\n  const workouts = await getAllWorkouts()\n  return workouts.find((workout) => workout.id === id) || null\n}\n\n// Save a workout\nexport const saveWorkout = async (workout: Workout): Promise<Workout> => {\n  try {\n    const workouts = await getAllWorkouts()\n\n    // If workout has no ID, create a new one\n    if (!workout.id) {\n      workout.id = uuidv4()\n    }\n\n    // Find if workout already exists to update or add new\n    const existingIndex = workouts.findIndex((w) => w.id === workout.id)\n\n    if (existingIndex >= 0) {\n      workouts[existingIndex] = workout\n    } else {\n      workouts.push(workout)\n    }\n\n    await AsyncStorage.setItem(WORKOUTS_STORAGE_KEY, JSON.stringify(workouts))\n    return workout\n  } catch (error) {\n    console.error(\"Error saving workout:\", error)\n    throw error\n  }\n}\n\n// Delete a workout\nexport const deleteWorkout = async (id: string): Promise<boolean> => {\n  try {\n    const workouts = await getAllWorkouts()\n    const filteredWorkouts = workouts.filter((workout) => workout.id !== id)\n    await AsyncStorage.setItem(WORKOUTS_STORAGE_KEY, JSON.stringify(filteredWorkouts))\n    return true\n  } catch (error) {\n    console.error(\"Error deleting workout:\", error)\n    return false\n  }\n}\n\n// Get progression recommendations for an exercise\nexport const getProgressionRecommendations = async (exerciseId: string): Promise<ProgressionRecommendation | null> => {\n  try {\n    // Get all workouts\n    const workouts = await getAllWorkouts()\n\n    // Find all completed workout entries that include this exercise\n    const relevantWorkouts = workouts\n      .filter((workout) => workout.isCompleted)\n      .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())\n\n    // Extract exercise entries for the specified exercise\n    const exerciseEntries = relevantWorkouts\n      .map((workout) => workout.exercises.find((entry) => entry.exerciseId === exerciseId))\n      .filter((entry) => entry !== undefined)\n\n    // If we don't have enough data, return null\n    if (exerciseEntries.length < 2) {\n      return null\n    }\n\n    // Get the most recent exercise entry\n    const latestEntry = exerciseEntries[0]!\n\n    // Simple progression logic for demonstration\n    // In a real app, this would be more sophisticated\n    const latestSets = latestEntry.sets.filter((set) => set.isCompleted)\n    const suggestedSets = latestSets.map((set) => {\n      // Clone the set\n      const newSet = { ...set, id: uuidv4(), isCompleted: false }\n\n      // Simple progression: If all reps completed and RPE < 8, increase weight by 5%\n      const allRepsCompleted = latestSets.every((s) => s.isCompleted)\n      const averageRPE = latestSets.reduce((sum, s) => sum + (s.rpe || 0), 0) / latestSets.length\n\n      if (allRepsCompleted && averageRPE < 8) {\n        newSet.weight = Math.round((newSet.weight * 1.05) / 2.5) * 2.5 // Round to nearest 2.5\n        return newSet\n      }\n\n      // If RPE was high but completed, keep the same weight\n      if (allRepsCompleted && averageRPE >= 8) {\n        return newSet\n      }\n\n      // If didn't complete all reps, reduce weight by 5%\n      newSet.weight = Math.round((newSet.weight * 0.95) / 2.5) * 2.5 // Round to nearest 2.5\n      return newSet\n    })\n\n    return {\n      exerciseId,\n      exerciseName: latestEntry.exercise.name,\n      suggestedSets,\n      reasoning: determineProgressionReasoning(latestSets, suggestedSets),\n      difficulty: determineDifficulty(latestSets, suggestedSets),\n    }\n  } catch (error) {\n    console.error(\"Error generating progression recommendations:\", error)\n    return null\n  }\n}\n\n// Helper to generate reasoning for progression recommendation\nconst determineProgressionReasoning = (latestSets: any[], suggestedSets: any[]): string => {\n  const weightDiff = suggestedSets[0].weight - latestSets[0].weight\n\n  if (weightDiff > 0) {\n    return `Based on your last workout's performance, we've increased the weight by ${weightDiff}lbs.`\n  } else if (weightDiff < 0) {\n    return `To ensure good form and progress, we've slightly reduced the weight by ${Math.abs(weightDiff)}lbs.`\n  } else {\n    return \"Based on your last workout, we recommend maintaining the same weight to continue building strength.\"\n  }\n}\n\n// Helper to determine difficulty change\nconst determineDifficulty = (latestSets: any[], suggestedSets: any[]): \"easier\" | \"same\" | \"harder\" => {\n  const totalWeightDiff = suggestedSets.reduce((sum, set, index) => {\n    return sum + (set.weight - latestSets[index].weight)\n  }, 0)\n\n  if (totalWeightDiff > 0) return \"harder\"\n  if (totalWeightDiff < 0) return \"easier\"\n  return \"same\"\n}\n\n// Add this export to your existing workoutService file\nexport const getActiveWorkout = async () => {\n  const workouts = await getAllWorkouts();\n  return workouts.find(workout => workout.isActive) || null;\n};\n\n"],"mappings":"AAAA,OAAOA,YAAY,MAAM,2CAA2C;AACpE,SAASC,EAAE,IAAIC,MAAM,QAAQ,MAAM;AAInC,MAAMC,oBAAoB,GAAG,UAAU;AAGvC,OAAO,MAAMC,cAAc,GAAG,MAAAA,CAAA,KAAgC;EAC5D,IAAI;IACF,MAAMC,YAAY,GAAG,MAAML,YAAY,CAACM,OAAO,CAACH,oBAAoB,CAAC;IACrE,OAAOE,YAAY,GAAGE,IAAI,CAACC,KAAK,CAACH,YAAY,CAAC,GAAG,EAAE;EACrD,CAAC,CAAC,OAAOI,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;IAClD,OAAO,EAAE;EACX;AACF,CAAC;AAGD,OAAO,MAAME,iBAAiB,GAAG,MAAOC,KAAa,IAAyB;EAC5E,MAAMC,QAAQ,GAAG,MAAMT,cAAc,CAAC,CAAC;EACvC,OAAOS,QAAQ,CAACC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK,IAAIC,IAAI,CAACD,CAAC,CAACE,IAAI,CAAC,CAACC,OAAO,CAAC,CAAC,GAAG,IAAIF,IAAI,CAACF,CAAC,CAACG,IAAI,CAAC,CAACC,OAAO,CAAC,CAAC,CAAC,CAACC,KAAK,CAAC,CAAC,EAAER,KAAK,CAAC;AACzG,CAAC;AAGD,OAAO,MAAMS,cAAc,GAAG,MAAOC,EAAU,IAA8B;EAC3E,MAAMT,QAAQ,GAAG,MAAMT,cAAc,CAAC,CAAC;EACvC,OAAOS,QAAQ,CAACU,IAAI,CAAEC,OAAO,IAAKA,OAAO,CAACF,EAAE,KAAKA,EAAE,CAAC,IAAI,IAAI;AAC9D,CAAC;AAGD,OAAO,MAAMG,WAAW,GAAG,MAAOD,OAAgB,IAAuB;EACvE,IAAI;IACF,MAAMX,QAAQ,GAAG,MAAMT,cAAc,CAAC,CAAC;IAGvC,IAAI,CAACoB,OAAO,CAACF,EAAE,EAAE;MACfE,OAAO,CAACF,EAAE,GAAGpB,MAAM,CAAC,CAAC;IACvB;IAGA,MAAMwB,aAAa,GAAGb,QAAQ,CAACc,SAAS,CAAEC,CAAC,IAAKA,CAAC,CAACN,EAAE,KAAKE,OAAO,CAACF,EAAE,CAAC;IAEpE,IAAII,aAAa,IAAI,CAAC,EAAE;MACtBb,QAAQ,CAACa,aAAa,CAAC,GAAGF,OAAO;IACnC,CAAC,MAAM;MACLX,QAAQ,CAACgB,IAAI,CAACL,OAAO,CAAC;IACxB;IAEA,MAAMxB,YAAY,CAAC8B,OAAO,CAAC3B,oBAAoB,EAAEI,IAAI,CAACwB,SAAS,CAAClB,QAAQ,CAAC,CAAC;IAC1E,OAAOW,OAAO;EAChB,CAAC,CAAC,OAAOf,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;IAC7C,MAAMA,KAAK;EACb;AACF,CAAC;AAGD,OAAO,MAAMuB,aAAa,GAAG,MAAOV,EAAU,IAAuB;EACnE,IAAI;IACF,MAAMT,QAAQ,GAAG,MAAMT,cAAc,CAAC,CAAC;IACvC,MAAM6B,gBAAgB,GAAGpB,QAAQ,CAACqB,MAAM,CAAEV,OAAO,IAAKA,OAAO,CAACF,EAAE,KAAKA,EAAE,CAAC;IACxE,MAAMtB,YAAY,CAAC8B,OAAO,CAAC3B,oBAAoB,EAAEI,IAAI,CAACwB,SAAS,CAACE,gBAAgB,CAAC,CAAC;IAClF,OAAO,IAAI;EACb,CAAC,CAAC,OAAOxB,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;IAC/C,OAAO,KAAK;EACd;AACF,CAAC;AAGD,OAAO,MAAM0B,6BAA6B,GAAG,MAAOC,UAAkB,IAAgD;EACpH,IAAI;IAEF,MAAMvB,QAAQ,GAAG,MAAMT,cAAc,CAAC,CAAC;IAGvC,MAAMiC,gBAAgB,GAAGxB,QAAQ,CAC9BqB,MAAM,CAAEV,OAAO,IAAKA,OAAO,CAACc,WAAW,CAAC,CACxCxB,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK,IAAIC,IAAI,CAACD,CAAC,CAACE,IAAI,CAAC,CAACC,OAAO,CAAC,CAAC,GAAG,IAAIF,IAAI,CAACF,CAAC,CAACG,IAAI,CAAC,CAACC,OAAO,CAAC,CAAC,CAAC;IAG1E,MAAMoB,eAAe,GAAGF,gBAAgB,CACrCG,GAAG,CAAEhB,OAAO,IAAKA,OAAO,CAACiB,SAAS,CAAClB,IAAI,CAAEmB,KAAK,IAAKA,KAAK,CAACN,UAAU,KAAKA,UAAU,CAAC,CAAC,CACpFF,MAAM,CAAEQ,KAAK,IAAKA,KAAK,KAAKC,SAAS,CAAC;IAGzC,IAAIJ,eAAe,CAACK,MAAM,GAAG,CAAC,EAAE;MAC9B,OAAO,IAAI;IACb;IAGA,MAAMC,WAAW,GAAGN,eAAe,CAAC,CAAC,CAAE;IAIvC,MAAMO,UAAU,GAAGD,WAAW,CAACE,IAAI,CAACb,MAAM,CAAEc,GAAG,IAAKA,GAAG,CAACV,WAAW,CAAC;IACpE,MAAMW,aAAa,GAAGH,UAAU,CAACN,GAAG,CAAEQ,GAAG,IAAK;MAE5C,MAAME,MAAM,GAAAC,MAAA,CAAAC,MAAA,KAAQJ,GAAG;QAAE1B,EAAE,EAAEpB,MAAM,CAAC,CAAC;QAAEoC,WAAW,EAAE;MAAK,EAAE;MAG3D,MAAMe,gBAAgB,GAAGP,UAAU,CAACQ,KAAK,CAAEC,CAAC,IAAKA,CAAC,CAACjB,WAAW,CAAC;MAC/D,MAAMkB,UAAU,GAAGV,UAAU,CAACW,MAAM,CAAC,CAACC,GAAG,EAAEH,CAAC,KAAKG,GAAG,IAAIH,CAAC,CAACI,GAAG,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,GAAGb,UAAU,CAACF,MAAM;MAE3F,IAAIS,gBAAgB,IAAIG,UAAU,GAAG,CAAC,EAAE;QACtCN,MAAM,CAACU,MAAM,GAAGC,IAAI,CAACC,KAAK,CAAEZ,MAAM,CAACU,MAAM,GAAG,IAAI,GAAI,GAAG,CAAC,GAAG,GAAG;QAC9D,OAAOV,MAAM;MACf;MAGA,IAAIG,gBAAgB,IAAIG,UAAU,IAAI,CAAC,EAAE;QACvC,OAAON,MAAM;MACf;MAGAA,MAAM,CAACU,MAAM,GAAGC,IAAI,CAACC,KAAK,CAAEZ,MAAM,CAACU,MAAM,GAAG,IAAI,GAAI,GAAG,CAAC,GAAG,GAAG;MAC9D,OAAOV,MAAM;IACf,CAAC,CAAC;IAEF,OAAO;MACLd,UAAU;MACV2B,YAAY,EAAElB,WAAW,CAACmB,QAAQ,CAACC,IAAI;MACvChB,aAAa;MACbiB,SAAS,EAAEC,6BAA6B,CAACrB,UAAU,EAAEG,aAAa,CAAC;MACnEmB,UAAU,EAAEC,mBAAmB,CAACvB,UAAU,EAAEG,aAAa;IAC3D,CAAC;EACH,CAAC,CAAC,OAAOxC,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,+CAA+C,EAAEA,KAAK,CAAC;IACrE,OAAO,IAAI;EACb;AACF,CAAC;AAGD,MAAM0D,6BAA6B,GAAGA,CAACrB,UAAiB,EAAEG,aAAoB,KAAa;EACzF,MAAMqB,UAAU,GAAGrB,aAAa,CAAC,CAAC,CAAC,CAACW,MAAM,GAAGd,UAAU,CAAC,CAAC,CAAC,CAACc,MAAM;EAEjE,IAAIU,UAAU,GAAG,CAAC,EAAE;IAClB,OAAO,2EAA2EA,UAAU,MAAM;EACpG,CAAC,MAAM,IAAIA,UAAU,GAAG,CAAC,EAAE;IACzB,OAAO,0EAA0ET,IAAI,CAACU,GAAG,CAACD,UAAU,CAAC,MAAM;EAC7G,CAAC,MAAM;IACL,OAAO,qGAAqG;EAC9G;AACF,CAAC;AAGD,MAAMD,mBAAmB,GAAGA,CAACvB,UAAiB,EAAEG,aAAoB,KAAmC;EACrG,MAAMuB,eAAe,GAAGvB,aAAa,CAACQ,MAAM,CAAC,CAACC,GAAG,EAAEV,GAAG,EAAEyB,KAAK,KAAK;IAChE,OAAOf,GAAG,IAAIV,GAAG,CAACY,MAAM,GAAGd,UAAU,CAAC2B,KAAK,CAAC,CAACb,MAAM,CAAC;EACtD,CAAC,EAAE,CAAC,CAAC;EAEL,IAAIY,eAAe,GAAG,CAAC,EAAE,OAAO,QAAQ;EACxC,IAAIA,eAAe,GAAG,CAAC,EAAE,OAAO,QAAQ;EACxC,OAAO,MAAM;AACf,CAAC;AAGD,OAAO,MAAME,gBAAgB,GAAG,MAAAA,CAAA,KAAY;EAC1C,MAAM7D,QAAQ,GAAG,MAAMT,cAAc,CAAC,CAAC;EACvC,OAAOS,QAAQ,CAACU,IAAI,CAACC,OAAO,IAAIA,OAAO,CAACmD,QAAQ,CAAC,IAAI,IAAI;AAC3D,CAAC","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}